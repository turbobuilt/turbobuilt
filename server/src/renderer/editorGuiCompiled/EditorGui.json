{"js":"\n\n    const importedModulesTurbobuilt = {\n        \"./components/TextEditor.vue\":(function(){const { defineComponent: _defineComponent } = Vue;\nconst { createCommentVNode: _createCommentVNode } = Vue;\nconst fullComponent = /* @__PURE__ */ _defineComponent({\n  __name: \"TextEditor\",\n  setup(__props, { expose: __expose }) {\n    function isInlineElement(el) {\n      const display = window.getComputedStyle(el).display;\n      return display === \"inline\" || display === \"inline-block\";\n    }\n    function isInlineContainer(el) {\n      for (const child of el.childNodes) {\n        if (child.nodeType === Node.ELEMENT_NODE && !isInlineElement(child)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function getHighestInlineAncestor(el) {\n      let current = el;\n      while (current.parentElement && isInlineElement(current.parentElement)) {\n        current = current.parentElement;\n      }\n      return current;\n    }\n    async function getRelativeXPath(el) {\n      const getXPath = (await import(\"https://unpkg.com/get-xpath/index.esm.js\")).default;\n      const container = el.closest(\"[class^=component-guid-]\");\n      let containerXpath = getXPath(container);\n      let xpath = getXPath(el);\n      return xpath.slice(containerXpath.length - 1);\n    }\n    function createTextFloatingEditor(target) {\n      const existing = document.getElementById(\"floating-editor\");\n      if (existing) existing.remove();\n      const editor = document.createElement(\"div\");\n      editor.id = \"floating-editor\";\n      editor.style.position = \"absolute\";\n      editor.style.background = \"#f0f0f0\";\n      editor.style.padding = \"5px\";\n      editor.style.border = \"1px solid #ccc\";\n      const boldButton = document.createElement(\"button\");\n      boldButton.textContent = \"Bold\";\n      boldButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        document.execCommand(\"bold\");\n      });\n      const italicButton = document.createElement(\"button\");\n      italicButton.textContent = \"Italic\";\n      italicButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        document.execCommand(\"italic\");\n      });\n      editor.appendChild(boldButton);\n      editor.appendChild(italicButton);\n      document.body.appendChild(editor);\n      const rect = target.getBoundingClientRect();\n      editor.style.top = window.scrollY + rect.top - editor.offsetHeight - 5 + \"px\";\n      editor.style.left = window.scrollX + rect.left + \"px\";\n    }\n    async function handleInput(event) {\n      const target = event.target;\n      const container = target.closest(\"[class^=component-guid-]\");\n      let relativeXpath = await getRelativeXPath(target);\n      let guid = container.className.match(/component-guid-([^\"']+)/)?.[1] || null;\n      let html = target.innerHTML;\n      window.opener.updateFileContent({ xpath: relativeXpath, guid, newContent: html });\n    }\n    function setupTextEditing() {\n      document.body.addEventListener(\"click\", async (event) => {\n        const target = event.target;\n        if (target.tagName.toLowerCase() === \"img\") return;\n        let editableElem = null;\n        let xpath = await getRelativeXPath(target);\n        let { result, error } = await window.opener.testIfCanEdit(xpath);\n        if (!result) {\n          window.dispatchEvent(new CustomEvent(\"show-toast\", {\n            detail: { title: \"Error Editing\", message: error }\n          }));\n          return;\n        }\n        if (isInlineElement(target)) {\n          editableElem = getHighestInlineAncestor(target);\n        } else if (isInlineContainer(target)) {\n          editableElem = target;\n        }\n        if (!editableElem) {\n          console.log(\"No editable element found\");\n          return;\n        }\n        if (!editableElem.hasAttribute(\"contenteditable\") || editableElem.getAttribute(\"contenteditable\") !== \"true\") {\n          editableElem.setAttribute(\"contenteditable\", \"true\");\n          createTextFloatingEditor(editableElem);\n          editableElem.addEventListener(\"input\", handleInput);\n        }\n      });\n    }\n    __expose({\n      setupTextEditing\n    });\n    return (_ctx, _cache) => {\n      return _createCommentVNode(\" No specific template needed as this is a utility component \");\n    };\n  }\n});\n;\nreturn fullComponent;})(),\n\"./components/ImageEditor.vue\":(function(){const { defineComponent: _defineComponent } = Vue;\nconst { createCommentVNode: _createCommentVNode } = Vue;\nconst fullComponent = /* @__PURE__ */ _defineComponent({\n  __name: \"ImageEditor\",\n  setup(__props, { expose: __expose }) {\n    function createPlaceholderSVG(shortDescription) {\n      const encodedText = encodeURIComponent(shortDescription || \"Image placeholder\");\n      return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"300\" height=\"200\" viewBox=\"0 0 300 200\">\n        <rect width=\"300\" height=\"200\" fill=\"#f0f0f0\" />\n        <text x=\"50%\" y=\"50%\" font-family=\"Arial\" font-size=\"16\" text-anchor=\"middle\" fill=\"#999\">${encodedText}</text>\n        <text x=\"50%\" y=\"65%\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#999\">Click to generate</text>\n    </svg>`;\n    }\n    function getCss(target) {\n      const compStyle = window.getComputedStyle(target);\n      let css = {};\n      if (compStyle.backgroundImage !== \"none\") {\n        css = {\n          backgroundImage: compStyle.backgroundImage,\n          backgroundColor: compStyle.backgroundColor,\n          borderRadius: compStyle.borderRadius\n        };\n      }\n      return css;\n    }\n    async function getRelativeXPath(el) {\n      const getXPath = (await import(\"https://unpkg.com/get-xpath/index.esm.js\")).default;\n      const container = el.closest(\"[class^=component-guid-]\");\n      let containerXpath = getXPath(container);\n      let xpath = getXPath(el);\n      return xpath.slice(containerXpath.length - 1);\n    }\n    function createImageFloatingEditor(target) {\n      const existing = document.getElementById(\"floating-editor\");\n      if (existing) existing.remove();\n      const editor = document.createElement(\"div\");\n      editor.id = \"floating-editor\";\n      editor.style.position = \"absolute\";\n      editor.style.background = \"#f0f0f0\";\n      editor.style.padding = \"5px\";\n      editor.style.border = \"1px solid #ccc\";\n      if (target.tagName.toLowerCase() === \"img\" && target.hasAttribute(\"short-description\")) {\n        const generateButton = document.createElement(\"button\");\n        generateButton.textContent = \"Generate Image\";\n        generateButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          await handleImageGeneration(target);\n        });\n        editor.appendChild(generateButton);\n        const editPromptButton = document.createElement(\"button\");\n        editPromptButton.textContent = \"Edit Prompt\";\n        editPromptButton.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          openImageStudio(target);\n        });\n        editor.appendChild(editPromptButton);\n      } else if (target.tagName.toLowerCase() === \"img\" && target.getAttribute(\"src\")) {\n        const changeImgButton = document.createElement(\"button\");\n        changeImgButton.textContent = \"Change Image\";\n        changeImgButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          const newUrl = prompt(\"Enter new image URL:\");\n          if (newUrl) {\n            target.src = newUrl;\n            let setAttributes = { src: newUrl };\n            window.opener.updateFileContent({ xpath: await getRelativeXPath(target), setAttributes });\n            target.dispatchEvent(new Event(\"input\"));\n          }\n        });\n        editor.appendChild(changeImgButton);\n      }\n      const compStyle = window.getComputedStyle(target);\n      if (compStyle.backgroundImage !== \"none\") {\n        const changeImgButton = document.createElement(\"button\");\n        changeImgButton.textContent = \"Change Image\";\n        changeImgButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          const newUrl = prompt(\"Enter new image URL:\");\n          if (newUrl) {\n            target.style.backgroundImage = `url(${newUrl})`;\n            window.opener.updateFileContent({ xpath: await getRelativeXPath(target), css: getCss(target) });\n            target.dispatchEvent(new Event(\"input\"));\n          }\n        });\n        editor.appendChild(changeImgButton);\n        const editStyleButton = document.createElement(\"button\");\n        editStyleButton.textContent = \"Edit Background Style\";\n        editStyleButton.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          const newBgColor = prompt(\"Enter new background color (e.g., #ffffff) or leave blank:\", target.style.backgroundColor || \"\");\n          const newBorderRadius = prompt(\"Enter new border radius (e.g., 5px) or leave blank:\", target.style.borderRadius || \"\");\n          if (newBgColor !== null && newBgColor.trim() !== \"\") {\n            target.style.backgroundColor = newBgColor.trim();\n          }\n          if (newBorderRadius !== null && newBorderRadius.trim() !== \"\") {\n            target.style.borderRadius = newBorderRadius.trim();\n          }\n          target.dispatchEvent(new Event(\"input\"));\n        });\n        editor.appendChild(editStyleButton);\n      }\n      document.body.appendChild(editor);\n      const rect = target.getBoundingClientRect();\n      editor.style.top = window.scrollY + rect.top - editor.offsetHeight - 5 + \"px\";\n      editor.style.left = window.scrollX + rect.left + \"px\";\n    }\n    async function handleImageGeneration(imgElement) {\n      const shortDescription = imgElement.getAttribute(\"short-description\");\n      const description = imgElement.getAttribute(\"description\") || shortDescription;\n      if (!shortDescription) {\n        window.dispatchEvent(new CustomEvent(\"show-toast\", {\n          detail: { title: \"Error\", message: \"No short description provided for image generation\" }\n        }));\n        return;\n      }\n      window.dispatchEvent(new CustomEvent(\"show-toast\", {\n        detail: { title: \"Generating Image\", message: `Generating: ${shortDescription}` }\n      }));\n      try {\n        const result = await window.opener.generateImage(shortDescription, description);\n        console.log(\"Image generation result:\", result);\n        if (result && result.success) {\n          if (result.objectId) {\n            imgElement.setAttribute(\"src\", result.url);\n            console.log(\"Doing img reference\");\n            const imgReference = `[img ${result.objectId}]`;\n            console.log(\"updating file content with\", imgReference);\n            window.opener.updateFileContent({\n              xpath: await getRelativeXPath(imgElement),\n              setAttributes: { src: imgReference }\n            });\n          } else if (result.url) {\n            imgElement.setAttribute(\"src\", result.url);\n            window.opener.updateFileContent({\n              xpath: await getRelativeXPath(imgElement),\n              setAttributes: { src: result.url }\n            });\n          } else {\n            throw new Error(\"Image generation succeeded but no objectId or URL was returned\");\n          }\n          imgElement.classList.remove(\"placeholder-image\");\n        } else {\n          throw new Error(result?.error || \"Failed to generate image\");\n        }\n      } catch (error) {\n        console.error(\"Image generation error:\", error);\n        window.dispatchEvent(new CustomEvent(\"show-toast\", {\n          detail: { title: \"Error\", message: \"Failed to generate image: \" + error }\n        }));\n      }\n    }\n    function openImageStudio(imgElement) {\n      const existingStudio = document.getElementById(\"image-prompt-studio\");\n      if (existingStudio) existingStudio.remove();\n      const shortDescription = imgElement.getAttribute(\"short-description\") || \"\";\n      const description = imgElement.getAttribute(\"description\") || \"\";\n      const studio = document.createElement(\"div\");\n      studio.id = \"image-prompt-studio\";\n      studio.className = \"image-prompt-studio\";\n      const title = document.createElement(\"h3\");\n      title.textContent = \"Edit Image Prompt\";\n      studio.appendChild(title);\n      const shortDescLabel = document.createElement(\"label\");\n      shortDescLabel.textContent = \"Short Description:\";\n      studio.appendChild(shortDescLabel);\n      const shortDescInput = document.createElement(\"input\");\n      shortDescInput.type = \"text\";\n      shortDescInput.value = shortDescription;\n      shortDescInput.className = \"prompt-input\";\n      studio.appendChild(shortDescInput);\n      const descLabel = document.createElement(\"label\");\n      descLabel.textContent = \"Image Prompt:\";\n      studio.appendChild(descLabel);\n      const descTextarea = document.createElement(\"textarea\");\n      descTextarea.value = description;\n      descTextarea.rows = 5;\n      descTextarea.className = \"prompt-textarea\";\n      studio.appendChild(descTextarea);\n      const buttonContainer = document.createElement(\"div\");\n      buttonContainer.className = \"button-container\";\n      const generateButton = document.createElement(\"button\");\n      generateButton.textContent = \"Generate Image\";\n      generateButton.className = \"generate-button\";\n      generateButton.addEventListener(\"click\", async () => {\n        const newShortDesc = shortDescInput.value.trim();\n        const newDesc = descTextarea.value.trim();\n        if (!newShortDesc) {\n          window.dispatchEvent(new CustomEvent(\"show-toast\", {\n            detail: { title: \"Error\", message: \"Short description is required\" }\n          }));\n          return;\n        }\n        imgElement.setAttribute(\"short-description\", newShortDesc);\n        imgElement.setAttribute(\"description\", newDesc);\n        studio.remove();\n        await handleImageGeneration(imgElement);\n      });\n      buttonContainer.appendChild(generateButton);\n      const cancelButton = document.createElement(\"button\");\n      cancelButton.textContent = \"Cancel\";\n      cancelButton.className = \"cancel-button\";\n      cancelButton.addEventListener(\"click\", () => {\n        studio.remove();\n      });\n      buttonContainer.appendChild(cancelButton);\n      studio.appendChild(buttonContainer);\n      document.body.appendChild(studio);\n    }\n    function addPlaceholdersToImages() {\n      const images = document.querySelectorAll('img[short-description]:not([src]), img[short-description][src=\"\"]');\n      images.forEach((img) => {\n        const shortDescription = img.getAttribute(\"short-description\");\n        img.src = createPlaceholderSVG(shortDescription);\n        img.classList.add(\"placeholder-image\");\n      });\n    }\n    async function resolveImageUrls() {\n      return;\n      try {\n        const imgTags = document.querySelectorAll('img[src*=\"[img \"]');\n        if (imgTags.length === 0) {\n          return { success: true, message: \"No images to resolve\" };\n        }\n        const imageObjectIds = /* @__PURE__ */ new Set();\n        imgTags.forEach((img) => {\n          const match = img.getAttribute(\"src\")?.match(/\\[img\\s+([^\\]]+)\\]/);\n          if (match && match[1]) {\n            imageObjectIds.add(match[1]);\n          }\n        });\n        if (imageObjectIds.size === 0) {\n          return { success: true, message: \"No valid objectIds found\" };\n        }\n        const result = await window.opener.getImageUrlsByObjectIds(Array.from(imageObjectIds));\n        if (!result.success || !result.items) {\n          throw new Error(\"Failed to fetch image URLs\");\n        }\n        imgTags.forEach((img) => {\n          const match = img.getAttribute(\"src\")?.match(/\\[img\\s+([^\\]]+)\\]/);\n          if (match && match[1]) {\n            const objectId = match[1];\n            if (result.items[objectId]) {\n              img.setAttribute(\"src\", \"https://clientsites.dreamgenerator.ai/\" + result.items[objectId][0].url);\n              img.classList.remove(\"placeholder-image\");\n            } else {\n              img.setAttribute(\"src\", createPlaceholderSVG(\"Image not found\"));\n              img.classList.add(\"placeholder-image\");\n            }\n          }\n        });\n        return { success: true, message: `Resolved ${imgTags.length} image URLs` };\n      } catch (err) {\n        console.error(\"Error resolving image URLs\", err);\n        return { success: false, error: err.toString() };\n      }\n    }\n    async function setupImageEditing() {\n      await resolveImageUrls();\n      addPlaceholdersToImages();\n      document.body.addEventListener(\"click\", async (event) => {\n        const target = event.target;\n        if (target.tagName.toLowerCase() === \"img\") {\n          event.preventDefault();\n          event.stopPropagation();\n          let xpath = await getRelativeXPath(target);\n          let { result, error } = await window.opener.testIfCanEdit(xpath);\n          if (!result) {\n            window.dispatchEvent(new CustomEvent(\"show-toast\", {\n              detail: { title: \"Error Editing\", message: error }\n            }));\n            return;\n          }\n          createImageFloatingEditor(target);\n          return;\n        }\n        const compStyle = window.getComputedStyle(target);\n        if (compStyle.backgroundImage !== \"none\" && compStyle.backgroundImage !== \"initial\") {\n          let xpath = await getRelativeXPath(target);\n          let { result, error } = await window.opener.testIfCanEdit(xpath);\n          if (!result) return;\n          createImageFloatingEditor(target);\n        }\n      });\n      const observer = new MutationObserver((mutations) => {\n        let shouldResolveUrls = false;\n        let shouldAddPlaceholders = false;\n        mutations.forEach((mutation) => {\n          if (mutation.type === \"childList\" || mutation.type === \"attributes\") {\n            if (mutation.type === \"attributes\" && mutation.attributeName === \"src\" && mutation.target.getAttribute(\"src\")?.startsWith(\"[img \")) {\n              shouldResolveUrls = true;\n            } else {\n              shouldAddPlaceholders = true;\n            }\n          }\n        });\n        if (shouldResolveUrls) {\n          resolveImageUrls().then(() => {\n            if (shouldAddPlaceholders) {\n              addPlaceholdersToImages();\n            }\n          });\n        } else if (shouldAddPlaceholders) {\n          addPlaceholdersToImages();\n        }\n      });\n      observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [\"src\", \"short-description\"]\n      });\n    }\n    __expose({\n      setupImageEditing,\n      addPlaceholdersToImages,\n      resolveImageUrls\n    });\n    return (_ctx, _cache) => {\n      return _createCommentVNode(\" No specific template needed as this is a utility component \");\n    };\n  }\n});\n;\nreturn fullComponent;})()\n    };\n    function loadComponentTurbobuilt(importPath) {\n        return importedModulesTurbobuilt[importPath];\n    }\n\nconst { defineComponent: _defineComponent } = Vue;\nconst { createVNode: _createVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = Vue;\nconst _hoisted_1 = { class: \"editor-gui\" };\nconst { onMounted, ref } = Vue;\nlet TextEditor = loadComponentTurbobuilt(\"./components/TextEditor.vue\");;\nlet ImageEditor = loadComponentTurbobuilt(\"./components/ImageEditor.vue\");;\nconst fullComponent = /* @__PURE__ */ _defineComponent({\n  __name: \"EditorGui\",\n  setup(__props) {\n    function isInlineElement(el) {\n      const display = window.getComputedStyle(el).display;\n      return display === \"inline\" || display === \"inline-block\";\n    }\n    function isInlineContainer(el) {\n      for (const child of el.childNodes) {\n        if (child.nodeType === Node.ELEMENT_NODE && !isInlineElement(child)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function getHighestInlineAncestor(el) {\n      let current = el;\n      while (current.parentElement && isInlineElement(current.parentElement)) {\n        current = current.parentElement;\n      }\n      return current;\n    }\n    function getCss(target) {\n      const compStyle = window.getComputedStyle(target);\n      let css = {};\n      if (compStyle.backgroundImage !== \"none\") {\n        css = {\n          backgroundImage: compStyle.backgroundImage,\n          backgroundColor: compStyle.backgroundColor,\n          borderRadius: compStyle.borderRadius\n        };\n      }\n      return css;\n    }\n    function createPlaceholderSVG(shortDescription) {\n      const encodedText = encodeURIComponent(shortDescription || \"Image placeholder\");\n      return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"300\" height=\"200\" viewBox=\"0 0 300 200\">\n        <rect width=\"300\" height=\"200\" fill=\"#f0f0f0\" />\n        <text x=\"50%\" y=\"50%\" font-family=\"Arial\" font-size=\"16\" text-anchor=\"middle\" fill=\"#999\">${encodedText}</text>\n        <text x=\"50%\" y=\"65%\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#999\">Click to generate</text>\n    </svg>`;\n    }\n    function createFloatingEditor(target) {\n      const existing = document.getElementById(\"floating-editor\");\n      if (existing) existing.remove();\n      const editor = document.createElement(\"div\");\n      editor.id = \"floating-editor\";\n      editor.style.position = \"absolute\";\n      editor.style.background = \"#f0f0f0\";\n      editor.style.padding = \"5px\";\n      editor.style.border = \"1px solid #ccc\";\n      const boldButton = document.createElement(\"button\");\n      boldButton.textContent = \"Bold\";\n      boldButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        document.execCommand(\"bold\");\n      });\n      const italicButton = document.createElement(\"button\");\n      italicButton.textContent = \"Italic\";\n      italicButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        document.execCommand(\"italic\");\n      });\n      editor.appendChild(boldButton);\n      editor.appendChild(italicButton);\n      if (target.tagName.toLowerCase() === \"img\" && target.hasAttribute(\"short-description\")) {\n        const generateButton = document.createElement(\"button\");\n        generateButton.textContent = \"Generate Image\";\n        generateButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          await handleImageGeneration(target);\n        });\n        editor.appendChild(generateButton);\n        const editPromptButton = document.createElement(\"button\");\n        editPromptButton.textContent = \"Edit Prompt\";\n        editPromptButton.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          openImageStudio(target);\n        });\n        editor.appendChild(editPromptButton);\n      } else if (target.tagName.toLowerCase() === \"img\" && target.getAttribute(\"src\")) {\n        const changeImgButton = document.createElement(\"button\");\n        changeImgButton.textContent = \"Change Image\";\n        changeImgButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          const newUrl = prompt(\"Enter new image URL:\");\n          if (newUrl) {\n            target.src = newUrl;\n            let setAttributes = { src: newUrl };\n            window.opener.updateFileContent({ xpath: await getRelativeXPath(target), setAttributes });\n            target.dispatchEvent(new Event(\"input\"));\n          }\n        });\n        editor.appendChild(changeImgButton);\n      }\n      const compStyle = window.getComputedStyle(target);\n      if (compStyle.backgroundImage !== \"none\") {\n        const changeImgButton = document.createElement(\"button\");\n        changeImgButton.textContent = \"Change Image\";\n        changeImgButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          const newUrl = prompt(\"Enter new image URL:\");\n          if (newUrl) {\n            target.style.backgroundImage = `url(${newUrl})`;\n            window.opener.updateFileContent({ xpath: await getRelativeXPath(target), css: getCss(target) });\n            target.dispatchEvent(new Event(\"input\"));\n          }\n        });\n        editor.appendChild(changeImgButton);\n        const editStyleButton = document.createElement(\"button\");\n        editStyleButton.textContent = \"Edit Background Style\";\n        editStyleButton.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          const newBgColor = prompt(\"Enter new background color (e.g., #ffffff) or leave blank:\", target.style.backgroundColor || \"\");\n          const newBorderRadius = prompt(\"Enter new border radius (e.g., 5px) or leave blank:\", target.style.borderRadius || \"\");\n          if (newBgColor !== null && newBgColor.trim() !== \"\") {\n            target.style.backgroundColor = newBgColor.trim();\n          }\n          if (newBorderRadius !== null && newBorderRadius.trim() !== \"\") {\n            target.style.borderRadius = newBorderRadius.trim();\n          }\n          target.dispatchEvent(new Event(\"input\"));\n        });\n        editor.appendChild(editStyleButton);\n      }\n      document.body.appendChild(editor);\n      const rect = target.getBoundingClientRect();\n      editor.style.top = window.scrollY + rect.top - editor.offsetHeight - 5 + \"px\";\n      editor.style.left = window.scrollX + rect.left + \"px\";\n    }\n    async function handleImageGeneration(imgElement) {\n      const shortDescription = imgElement.getAttribute(\"short-description\");\n      const description = imgElement.getAttribute(\"description\") || shortDescription;\n      if (!shortDescription) {\n        showToast(\"Error\", \"No short description provided for image generation\");\n        return;\n      }\n      showToast(\"Generating Image\", `Generating: ${shortDescription}`);\n      try {\n        const result = await window.opener.generateImage(shortDescription, description);\n        if (result && result.url) {\n          imgElement.setAttribute(\"src\", result.url);\n          window.opener.updateFileContent({\n            xpath: await getRelativeXPath(imgElement),\n            setAttributes: { src: result.url }\n          });\n        } else {\n          showToast(\"Error\", \"Failed to generate image\");\n        }\n      } catch (error) {\n        console.error(\"Image generation error:\", error);\n        showToast(\"Error\", \"Failed to generate image: \" + error);\n      }\n    }\n    function openImageStudio(imgElement) {\n      const existingStudio = document.getElementById(\"image-prompt-studio\");\n      if (existingStudio) existingStudio.remove();\n      const shortDescription = imgElement.getAttribute(\"short-description\") || \"\";\n      const description = imgElement.getAttribute(\"description\") || \"\";\n      const studio = document.createElement(\"div\");\n      studio.id = \"image-prompt-studio\";\n      studio.className = \"image-prompt-studio\";\n      const title = document.createElement(\"h3\");\n      title.textContent = \"Edit Image Prompt\";\n      studio.appendChild(title);\n      const shortDescLabel = document.createElement(\"label\");\n      shortDescLabel.textContent = \"Short Description:\";\n      studio.appendChild(shortDescLabel);\n      const shortDescInput = document.createElement(\"input\");\n      shortDescInput.type = \"text\";\n      shortDescInput.value = shortDescription;\n      shortDescInput.className = \"prompt-input\";\n      studio.appendChild(shortDescInput);\n      const descLabel = document.createElement(\"label\");\n      descLabel.textContent = \"Image Prompt:\";\n      studio.appendChild(descLabel);\n      const descTextarea = document.createElement(\"textarea\");\n      descTextarea.value = description;\n      descTextarea.rows = 5;\n      descTextarea.className = \"prompt-textarea\";\n      studio.appendChild(descTextarea);\n      const buttonContainer = document.createElement(\"div\");\n      buttonContainer.className = \"button-container\";\n      const generateButton = document.createElement(\"button\");\n      generateButton.textContent = \"Generate Image\";\n      generateButton.className = \"generate-button\";\n      generateButton.addEventListener(\"click\", async () => {\n        const newShortDesc = shortDescInput.value.trim();\n        const newDesc = descTextarea.value.trim();\n        if (!newShortDesc) {\n          showToast(\"Error\", \"Short description is required\");\n          return;\n        }\n        imgElement.setAttribute(\"short-description\", newShortDesc);\n        imgElement.setAttribute(\"description\", newDesc);\n        studio.remove();\n        await handleImageGeneration(imgElement);\n      });\n      buttonContainer.appendChild(generateButton);\n      const cancelButton = document.createElement(\"button\");\n      cancelButton.textContent = \"Cancel\";\n      cancelButton.className = \"cancel-button\";\n      cancelButton.addEventListener(\"click\", () => {\n        studio.remove();\n      });\n      buttonContainer.appendChild(cancelButton);\n      studio.appendChild(buttonContainer);\n      document.body.appendChild(studio);\n    }\n    async function getRelativeXPath(el) {\n      const getXPath = (await import(\"https://unpkg.com/get-xpath/index.esm.js\")).default;\n      const container = el.closest(\"[class^=component-guid-]\");\n      let containerXpath = getXPath(container);\n      let xpath = getXPath(el);\n      return xpath.slice(containerXpath.length - 1);\n    }\n    async function handleInput(event) {\n      const target = event.target;\n      const container = target.closest(\"[class^=component-guid-]\");\n      let relativeXpath = await getRelativeXPath(target);\n      let guid = container.className.match(/component-guid-([^\"']+)/)?.[1] || null;\n      let html = target.innerHTML;\n      window.opener.updateFileContent({ xpath: relativeXpath, guid, newContent: html });\n    }\n    function showToast(title, msg) {\n      let toastContainer = document.getElementById(\"toast-container\");\n      if (!toastContainer) {\n        toastContainer = document.createElement(\"div\");\n        toastContainer.id = \"toast-container\";\n        document.body.appendChild(toastContainer);\n      }\n      const toast = document.createElement(\"div\");\n      toast.className = \"toast\";\n      const toastTitle = document.createElement(\"div\");\n      toastTitle.className = \"toast-title\";\n      toastTitle.textContent = title;\n      const toastMessage = document.createElement(\"div\");\n      toastMessage.className = \"toast-message\";\n      toastMessage.textContent = msg;\n      toast.appendChild(toastTitle);\n      toast.appendChild(toastMessage);\n      toastContainer.insertBefore(toast, toastContainer.firstChild);\n      const toasts = toastContainer.querySelectorAll(\".toast\");\n      let currentOffset = 0;\n      toasts.forEach((t) => {\n        t.style.transform = `translateY(${currentOffset}px)`;\n        currentOffset += t.offsetHeight + 10;\n      });\n      setTimeout(() => {\n        toast.classList.add(\"visible\");\n      }, 10);\n      setTimeout(() => {\n        toast.classList.remove(\"visible\");\n        toast.classList.add(\"fading\");\n        setTimeout(() => {\n          if (toastContainer.contains(toast)) {\n            toastContainer.removeChild(toast);\n            const remainingToasts = toastContainer.querySelectorAll(\".toast\");\n            let newOffset = 0;\n            remainingToasts.forEach((t) => {\n              t.style.transform = `translateY(${newOffset}px)`;\n              newOffset += t.offsetHeight + 10;\n            });\n          }\n        }, 300);\n      }, 3e3);\n    }\n    const textEditorRef = ref(null);\n    const imageEditorRef = ref(null);\n    onMounted(() => {\n      console.log(\"Editor GUI mounted\");\n      window.addEventListener(\"show-toast\", (event) => {\n        const { title, message } = event.detail;\n        showToast(title, message);\n      });\n      if (textEditorRef.value) {\n        textEditorRef.value.setupTextEditing();\n      }\n      if (imageEditorRef.value) {\n        imageEditorRef.value.setupImageEditing();\n      }\n    });\n    function addPlaceholdersToImages() {\n      const images = document.querySelectorAll('img[short-description]:not([src]), img[short-description][src=\"\"]');\n      images.forEach((img) => {\n        const shortDescription = img.getAttribute(\"short-description\");\n        img.src = createPlaceholderSVG(shortDescription);\n        img.classList.add(\"placeholder-image\");\n      });\n    }\n    function setupImages() {\n      window.opener.resolveImageUrls().then((result) => {\n        console.log(\"Image URL resolution result:\", result);\n        addPlaceholdersToImages();\n      }).catch((err) => {\n        console.error(\"Error resolving image URLs:\", err);\n        addPlaceholdersToImages();\n      });\n    }\n    onMounted(() => {\n      console.log(\"mounted\");\n      if (imageEditorRef.value) {\n        imageEditorRef.value.setupImageEditing();\n        imageEditorRef.value.resolveImageUrls().then(() => {\n          imageEditorRef.value.addPlaceholdersToImages();\n        });\n      }\n      if (textEditorRef.value) {\n        textEditorRef.value.setupTextEditing();\n      }\n      document.body.addEventListener(\"click\", async (event) => {\n        const target = event.target;\n        console.log(\"Clicked element:\", target);\n        if (!target) return;\n        if (target.tagName.toLowerCase() === \"img\" && target.hasAttribute(\"short-description\")) {\n          event.preventDefault();\n          event.stopPropagation();\n          createFloatingEditor(target);\n          return;\n        }\n        let editableElem = null;\n        let xpath = await getRelativeXPath(target);\n        console.log(\"Can edit\", await window.opener.testIfCanEdit(xpath));\n        let { result, error } = await window.opener.testIfCanEdit(xpath);\n        if (!result) {\n          showToast(\"Error Editing\", error);\n          return;\n        }\n        if (isInlineElement(target)) {\n          editableElem = getHighestInlineAncestor(target);\n        } else if (isInlineContainer(target)) {\n          editableElem = target;\n        }\n        if (!editableElem) {\n          console.log(\"No editable element found\");\n          return;\n        }\n        if (!editableElem.hasAttribute(\"contenteditable\") || editableElem.getAttribute(\"contenteditable\") !== \"true\") {\n          editableElem.setAttribute(\"contenteditable\", \"true\");\n          createFloatingEditor(editableElem);\n          editableElem.addEventListener(\"input\", handleInput);\n        }\n      });\n      const observer = new MutationObserver((mutations) => {\n        let shouldProcessImages = false;\n        mutations.forEach((mutation) => {\n          if (mutation.type === \"childList\" || mutation.type === \"attributes\") {\n            if (mutation.type === \"attributes\" && mutation.attributeName === \"src\" && mutation.target.getAttribute(\"src\")?.startsWith(\"[img \")) {\n              shouldProcessImages = true;\n            } else if (mutation.type === \"childList\") {\n              mutation.addedNodes.forEach((node) => {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                  const element = node;\n                  if (element.tagName === \"IMG\" && element.getAttribute(\"src\")?.startsWith(\"[img \")) {\n                    shouldProcessImages = true;\n                  } else if (element.querySelectorAll) {\n                    const nestedImgs = element.querySelectorAll('img[src^=\"[img \"]');\n                    if (nestedImgs.length > 0) {\n                      shouldProcessImages = true;\n                    }\n                  }\n                }\n              });\n            }\n          }\n        });\n        if (shouldProcessImages) {\n          window.opener.resolveImageUrls().then(() => {\n            addPlaceholdersToImages();\n          });\n        } else {\n          addPlaceholdersToImages();\n        }\n      });\n      observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [\"src\", \"short-description\"]\n      });\n    });\n    return (_ctx, _cache) => {\n      return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n        _createVNode(\n          TextEditor,\n          {\n            ref_key: \"textEditorRef\",\n            ref: textEditorRef\n          },\n          null,\n          512\n          /* NEED_PATCH */\n        ),\n        _createVNode(\n          ImageEditor,\n          {\n            ref_key: \"imageEditorRef\",\n            ref: imageEditorRef\n          },\n          null,\n          512\n          /* NEED_PATCH */\n        )\n      ]);\n    };\n  }\n});\n","css":"/* Toast notifications */\n#toast-container {\n  position: fixed;\n  top: 20px;\n  right: 20px;\n  z-index: 9999;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n}\n\n.toast {\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 12px 16px;\n  margin-bottom: 10px;\n  min-width: 250px;\n  max-width: 350px;\n  opacity: 0;\n  transform: translateY(0);\n  transition: opacity 0.3s ease, transform 0.3s ease;\n  border-left: 4px solid #f44336;\n}\n\n.toast.visible {\n  opacity: 1;\n}\n\n.toast.fading {\n  opacity: 0;\n}\n\n.toast-title {\n  font-weight: bold;\n  margin-bottom: 5px;\n  color: #333;\n}\n\n.toast-message {\n  color: #666;\n  word-break: break-word;\n}\n\n/* Image studio for prompt editing */\n.image-prompt-studio {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background: white;\n  padding: 20px;\n  border-radius: 8px;\n  box-shadow: 0 2px 20px rgba(0, 0, 0, 0.2);\n  z-index: 10000;\n  width: 80%;\n  max-width: 500px;\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.image-prompt-studio h3 {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.prompt-input, .prompt-textarea {\n  width: 100%;\n  padding: 8px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-family: inherit;\n}\n\n.button-container {\n  display: flex;\n  justify-content: flex-end;\n  gap: 10px;\n  margin-top: 10px;\n}\n\n.generate-button, .cancel-button {\n  padding: 8px 16px;\n  border-radius: 4px;\n  border: none;\n  cursor: pointer;\n}\n\n.generate-button {\n  background-color: #4CAF50;\n  color: white;\n}\n\n.cancel-button {\n  background-color: #f44336;\n  color: white;\n}\n\n/* Placeholder image styles */\n.placeholder-image {\n  border: 1px dashed #ccc;\n  cursor: pointer;\n}\n\n/* Floating editor enhancements */\n#floating-editor {\n  display: flex;\n  gap: 5px;\n}\n\n#floating-editor button {\n  padding: 4px 8px;\n  border-radius: 3px;\n  border: 1px solid #ccc;\n  background-color: white;\n  cursor: pointer;\n}\n\n#floating-editor button:hover {\n  background-color: #f0f0f0;\n}\n/* Floating editor styles */\n#floating-editor {\n  display: flex;\n  gap: 5px;\n}\n\n#floating-editor button {\n  padding: 4px 8px;\n  border-radius: 3px;\n  border: 1px solid #ccc;\n  background-color: white;\n  cursor: pointer;\n}\n\n#floating-editor button:hover {\n  background-color: #f0f0f0;\n}\n\n/* Image studio for prompt editing */\n.image-prompt-studio {\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 20px rgba(0, 0, 0, 0.2);\n    z-index: 10000;\n    width: 80%;\n    max-width: 500px;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.image-prompt-studio h3 {\n    margin-top: 0;\n    margin-bottom: 10px;\n}\n\n.prompt-input,\n.prompt-textarea {\n    width: 100%;\n    padding: 8px;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    font-family: inherit;\n}\n\n.button-container {\n    display: flex;\n    justify-content: flex-end;\n    gap: 10px;\n    margin-top: 10px;\n}\n\n.generate-button,\n.cancel-button {\n    padding: 8px 16px;\n    border-radius: 4px;\n    border: none;\n    cursor: pointer;\n}\n\n.generate-button {\n    background-color: #4CAF50;\n    color: white;\n}\n\n.cancel-button {\n    background-color: #f44336;\n    color: white;\n}\n\n/* Placeholder image styles */\n.placeholder-image {\n    border: 1px dashed #ccc;\n    cursor: pointer;\n}\n"}