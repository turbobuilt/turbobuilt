{"js":"const { defineComponent: _defineComponent } = Vue;\nconst { openBlock: _openBlock, createElementBlock: _createElementBlock } = Vue;\nconst _hoisted_1 = { class: \"editor-gui\" };\nconst { onMounted } = Vue;\nconst fullComponent = /* @__PURE__ */ _defineComponent({\n  __name: \"EditorGui\",\n  setup(__props) {\n    function isInlineElement(el) {\n      const display = window.getComputedStyle(el).display;\n      return display === \"inline\" || display === \"inline-block\";\n    }\n    function isInlineContainer(el) {\n      for (const child of el.childNodes) {\n        if (child.nodeType === Node.ELEMENT_NODE && !isInlineElement(child)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function getHighestInlineAncestor(el) {\n      let current = el;\n      while (current.parentElement && isInlineElement(current.parentElement)) {\n        current = current.parentElement;\n      }\n      return current;\n    }\n    function getCss(target) {\n      const compStyle = window.getComputedStyle(target);\n      let css = {};\n      if (compStyle.backgroundImage !== \"none\") {\n        css = {\n          backgroundImage: compStyle.backgroundImage,\n          backgroundColor: compStyle.backgroundColor,\n          borderRadius: compStyle.borderRadius\n        };\n      }\n      return css;\n    }\n    function createFloatingEditor(target) {\n      const existing = document.getElementById(\"floating-editor\");\n      if (existing) existing.remove();\n      const editor = document.createElement(\"div\");\n      editor.id = \"floating-editor\";\n      editor.style.position = \"absolute\";\n      editor.style.background = \"#f0f0f0\";\n      editor.style.padding = \"5px\";\n      editor.style.border = \"1px solid #ccc\";\n      const boldButton = document.createElement(\"button\");\n      boldButton.textContent = \"Bold\";\n      boldButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        document.execCommand(\"bold\");\n      });\n      const italicButton = document.createElement(\"button\");\n      italicButton.textContent = \"Italic\";\n      italicButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        document.execCommand(\"italic\");\n      });\n      editor.appendChild(boldButton);\n      editor.appendChild(italicButton);\n      const compStyle = window.getComputedStyle(target);\n      if (compStyle.backgroundImage !== \"none\" || target.tagName.toLowerCase() === \"img\" && target.getAttribute(\"src\")) {\n        const changeImgButton = document.createElement(\"button\");\n        changeImgButton.textContent = \"Change Image\";\n        changeImgButton.addEventListener(\"click\", async (e) => {\n          e.stopPropagation();\n          const newUrl = prompt(\"Enter new image URL:\");\n          if (newUrl) {\n            if (compStyle.backgroundImage !== \"none\") {\n              target.style.backgroundImage = `url(${newUrl})`;\n              window.opener.updateFileContent({ xpath: await getRelativeXPath(target), css: getCss(target) });\n            } else if (target.tagName.toLowerCase() === \"img\") {\n              target.src = newUrl;\n              let setAttributes = { src: newUrl };\n              window.opener.updateFileContent({ xpath: await getRelativeXPath(target), setAttributes });\n            }\n            target.dispatchEvent(new Event(\"input\"));\n          }\n        });\n        editor.appendChild(changeImgButton);\n        if (compStyle.backgroundImage !== \"none\") {\n          const editStyleButton = document.createElement(\"button\");\n          editStyleButton.textContent = \"Edit Background Style\";\n          editStyleButton.addEventListener(\"click\", (e) => {\n            e.stopPropagation();\n            const newBgColor = prompt(\"Enter new background color (e.g., #ffffff) or leave blank:\", target.style.backgroundColor || \"\");\n            const newBorderRadius = prompt(\"Enter new border radius (e.g., 5px) or leave blank:\", target.style.borderRadius || \"\");\n            if (newBgColor !== null && newBgColor.trim() !== \"\") {\n              target.style.backgroundColor = newBgColor.trim();\n            }\n            if (newBorderRadius !== null && newBorderRadius.trim() !== \"\") {\n              target.style.borderRadius = newBorderRadius.trim();\n            }\n            target.dispatchEvent(new Event(\"input\"));\n          });\n          editor.appendChild(editStyleButton);\n        }\n      }\n      document.body.appendChild(editor);\n      const rect = target.getBoundingClientRect();\n      editor.style.top = window.scrollY + rect.top - editor.offsetHeight - 5 + \"px\";\n      editor.style.left = window.scrollX + rect.left + \"px\";\n    }\n    async function getRelativeXPath(el) {\n      const getXPath = (await import(\"https://unpkg.com/get-xpath/index.esm.js\")).default;\n      const container = el.closest(\"[class^=component-guid-]\");\n      let containerXpath = getXPath(container);\n      let xpath = getXPath(el);\n      return xpath.slice(containerXpath.length - 1);\n    }\n    async function handleInput(event) {\n      const target = event.target;\n      const container = target.closest(\"[class^=component-guid-]\");\n      let relativeXpath = await getRelativeXPath(target);\n      let guid = container.className.match(/component-guid-([^\"']+)/)?.[1] || null;\n      let html = target.innerHTML;\n      window.opener.updateFileContent({ xpath: relativeXpath, guid, newContent: html });\n    }\n    function showToast(title, msg) {\n      let toastContainer = document.getElementById(\"toast-container\");\n      if (!toastContainer) {\n        toastContainer = document.createElement(\"div\");\n        toastContainer.id = \"toast-container\";\n        document.body.appendChild(toastContainer);\n      }\n      const toast = document.createElement(\"div\");\n      toast.className = \"toast\";\n      const toastTitle = document.createElement(\"div\");\n      toastTitle.className = \"toast-title\";\n      toastTitle.textContent = title;\n      const toastMessage = document.createElement(\"div\");\n      toastMessage.className = \"toast-message\";\n      toastMessage.textContent = msg;\n      toast.appendChild(toastTitle);\n      toast.appendChild(toastMessage);\n      toastContainer.insertBefore(toast, toastContainer.firstChild);\n      const toasts = toastContainer.querySelectorAll(\".toast\");\n      let currentOffset = 0;\n      toasts.forEach((t) => {\n        t.style.transform = `translateY(${currentOffset}px)`;\n        currentOffset += t.offsetHeight + 10;\n      });\n      setTimeout(() => {\n        toast.classList.add(\"visible\");\n      }, 10);\n      setTimeout(() => {\n        toast.classList.remove(\"visible\");\n        toast.classList.add(\"fading\");\n        setTimeout(() => {\n          if (toastContainer.contains(toast)) {\n            toastContainer.removeChild(toast);\n            const remainingToasts = toastContainer.querySelectorAll(\".toast\");\n            let newOffset = 0;\n            remainingToasts.forEach((t) => {\n              t.style.transform = `translateY(${newOffset}px)`;\n              newOffset += t.offsetHeight + 10;\n            });\n          }\n        }, 300);\n      }, 3e3);\n    }\n    onMounted(() => {\n      console.log(\"mounted\");\n      document.body.addEventListener(\"click\", async (event) => {\n        const target = event.target;\n        console.log(\"Clicked element:\", target);\n        if (!target) return;\n        let editableElem = null;\n        let xpath = await getRelativeXPath(target);\n        console.log(\"Can edit\", await window.opener.testIfCanEdit(xpath));\n        let { result, error } = await window.opener.testIfCanEdit(xpath);\n        if (!result) {\n          showToast(\"Error Editing\", error);\n          return;\n        }\n        if (isInlineElement(target)) {\n          editableElem = getHighestInlineAncestor(target);\n        } else if (isInlineContainer(target)) {\n          editableElem = target;\n        }\n        if (!editableElem) {\n          console.log(\"No editable element found\");\n          return;\n        }\n        if (!editableElem.hasAttribute(\"contenteditable\") || editableElem.getAttribute(\"contenteditable\") !== \"true\") {\n          editableElem.setAttribute(\"contenteditable\", \"true\");\n          createFloatingEditor(editableElem);\n          editableElem.addEventListener(\"input\", handleInput);\n        }\n      });\n    });\n    return (_ctx, _cache) => {\n      return _openBlock(), _createElementBlock(\"div\", _hoisted_1);\n    };\n  }\n});\n","css":"#toast-container {\n  position: fixed;\n  top: 20px;\n  right: 20px;\n  z-index: 9999;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n}\n\n.toast {\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 12px 16px;\n  margin-bottom: 10px;\n  min-width: 250px;\n  max-width: 350px;\n  opacity: 0;\n  transform: translateY(0);\n  transition: opacity 0.3s ease, transform 0.3s ease;\n  border-left: 4px solid #f44336;\n}\n\n.toast.visible {\n  opacity: 1;\n}\n\n.toast.fading {\n  opacity: 0;\n}\n\n.toast-title {\n  font-weight: bold;\n  margin-bottom: 5px;\n  color: #333;\n}\n\n.toast-message {\n  color: #666;\n  word-break: break-word;\n}\n"}